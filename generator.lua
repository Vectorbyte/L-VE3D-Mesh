----------------------------
    -- Generation Functions
----------------------------
local generator = {}

-- Creates UVs from meshes generated by quads ----------------------------------------------
function generator.create_quad_uvs(texture, coords, vertices)
    -- UV table
    local uvs = {}
    
    -- UV parameters
    local x, y, w, h
    
    -- Maximum ammount of loops
    local max = vertices/12
    
    -- Create the UV quads for each face of the cuboid
    for i = 1, max do
        -- Defaults
        if not coords[i] then
            x, y = x or 1, y or 1
            w, h = w or 64, h or 64
        else
            x, y = coords[i].x or 1, coords[i].y or 1
            w, h = coords[i].w or 64, coords[i].h or 64
        end
        
        -- Calculate the normalized coordinates
        local min = cpml.vec2(x/texture:getWidth(), x/texture:getHeight())
        local max = cpml.vec2(w/texture:getWidth(), h/texture:getHeight())
        
        local add = (i-1)*8
        
        -- UV Quad
        -- Vertex 1
        uvs[add+1] = min.x
        uvs[add+2] = max.y
        -- Vertex 2
        uvs[add+3] = max.x
        uvs[add+4] = max.y
        -- Vertex 3
        uvs[add+5] = max.x
        uvs[add+6] = min.y
        -- Vertex 4
        uvs[add+7] = min.x
        uvs[add+8] = min.y
    end
    
    return uvs
end

-- Creates UVs from meshes generated by loops ----------------------------------------------
function generator.create_loop_uvs(texture, coords, loops) 
    local add_x  = math.pi*2/loops.x
    local center = cpml.vec2(coords.x, coords.y)
    
    -- Expansion midpoint
    local vertical_midpoint = loops.z/2
    
    local uvs = {
        center.x/texture:getWidth(), center.y/texture:getHeight()
    }
    
    -- Stack horizontal loops
    for z = 1, loops.z - 3 do
        -- Solve vertex offset
        local new_z = z*loops.z/(loops.z - 2)
        local mid_expand = -math.cos((new_z - vertical_midpoint)/loops.z*math.pi)

        -- Create horizontal loop
        for x = 0, math.pi*2 - (add_x - cpml.constants.FLT_EPSILON), add_x do
            local uv_x = math.cos(x)*(center.x*mid_expand) + center.x 
            local uv_y = -math.sin(x)*(center.y*mid_expand) + center.y

            table.insert(uvs, uv_x/texture:getWidth())
            table.insert(uvs, uv_y/texture:getHeight())
        end
    end
    
    -- Add final vertex
    table.insert(uvs, center.x/texture:getWidth())
    table.insert(uvs, center.y/texture:getHeight())
    
    return uvs
end

-- Creates vertex indices from meshes generated by quads
function generator.create_quad_index(vertices)
    local indices = {}  
    local v = 0
    
    for i = 1, vertices/3, 1 do indices[#indices+1] = i end
    for i = 4, vertices/3, 4 do 
        table.insert(indices, 4*(i/4)+v, i-3)
        v = v + 1
        table.insert(indices, 4*(i/4)+v, i-1) 
        v = v + 1
    end
    
    return indices
end

-- Creates vertex indices from meshes generated by edge loops ------------------------------
function generator.create_loop_index(loops)
    -- Create vertex indices
    local indices = {}  
    
    local min_val = 3
    local max_val = loops.x + 2
    
    -- Create indices for the bottom triangles
    for i = min_val, max_val, 1 do
        table.insert(indices, i - 1)
        table.insert(indices, 1)
        
        if i == max_val then
            table.insert(indices, min_val - 1)
        else
            table.insert(indices, i)
        end
    end
    
    min_val = 2
    max_val = loops.x + 1
    
    -- Create indices for mid triangles
    for z = 1, loops.z - 4 do
        for x = min_val, max_val, 1 do
            local val = x + loops.x
            
            -- Triangle index 1
            table.insert(indices, val)
            table.insert(indices, x)
            -- Wrap triangle index 1
            if x == max_val then
                table.insert(indices, min_val)
            else
                table.insert(indices, x+1)
            end
            
            -- Triangle index 2
            -- Wrap triangle index 2
            if x == max_val then
                table.insert(indices, min_val)
                table.insert(indices, val+1-loops.x)
                table.insert(indices, val)
            else
                table.insert(indices, x+1)
                table.insert(indices, val+1)
                table.insert(indices, val)
            end
        end
        
        min_val = min_val + loops.x
        max_val = max_val + loops.x
    end

    min_val = min_val + 1
    max_val = min_val - 1 + loops.x
    
    -- Create indices for the top triangles
    for i = min_val, max_val, 1 do
        table.insert(indices, max_val)
        table.insert(indices, i - 1)
        
        if i == max_val then
            table.insert(indices, min_val - 1)
        else
            table.insert(indices, i)
        end
    end

    return indices
end

-- UV/vertex table merger ------------------------------------------------------------------
function generator.uv_merge(a, b)
    local ret = {}
    
    for i = 1, #a do
        local j, k = i*3, i*2
        
        -- Merge Vertex and UV coordinates
        ret[i] = {
            a[j-2], -- Vertex x
            a[j-1], -- Vertex y
            a[j-0], -- Vertex z
            b[k-1], -- UV x
            b[k-0]  -- UV y
        }
    end
    
    return ret
end

return generator
